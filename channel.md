# 通道 channel

Go 采用了 CSP 的并发模型。它的基础是 channel 和 goroutine。

goroutine 是并发执行的实体（后续文章会讲）。

channel 是 Go 语言的一种数据类型，是传递消息的载体，使用起来十分简单，而且是并发安全的。

## 基本使用

我们可以将通道认为是队列（先进先出），队列的长度就是通道容纳消息的容量。 
消息的类型可以是任意的，它需要在我们初始化或声明通道变量的时候指定。

通道的关键字是`chan`，通道变量的类型是`chan <type>`，属于 *引用类型*，

我们可以通过下面的方式得到通道变量：

```Go
// 声明通道，chan0是一个int类型的通道，初始值为nil
var chan0 chan int

// 通过make初始化通道，make的第二个参数是通道的容量
chan1 := make(chan int, 5)
```

我们使用操作符`<-`对通道进行操作，它可以放在通道的左边或右边，分别代表`从通道获取消息`和`将消息放入通道`。下面是具体例子：

```Go
chan1 := make(chan int, 5)

// 将值1和2分别放入通道中，按照队列的顺序，通道将存放[1, 2]
chan1 <- 1
chan1 <- 2

// 从通道中获取消息，此时elem1的值将是1。
elem1 := <-chan1
```

> 对于已经不再使用的通道，我们要养成主动关闭的习惯，接收方可以通过关闭的动作感知到通道的状态，而做出处理。

关闭通道使用`close`方法：

```Go
close(chan1)
```

对于通道的容量，有下面的特性：

- 当通道的容量已满时，发送操作会被阻塞，直到有空位为止；
- 当通道为空时，接收操作会被阻塞，直到有新的元素到来。

## 通道特性

我们现在知道了通道是如何使用的，包括声明，赋值取值和关闭。

通道存放的消息，其实都是元素的副本或者是元素引用的副本（浅复制），而不是原始元素。所以在元素进入通道时，通道是做了「复制」操作的。

还记得我们在最开始的时候说过，通道是「并发安全」的，使用简单，是因为通道本身的特性为我们做了保证：

1. 阻塞，对于发送操作和接收操作，在操作没有完成之前，代码会被阻塞，不会进行后续操作；
2. 同一个通道的发送操作是互斥的，接收操作也是互斥的，原因是为了保证顺序的一致，先到达的操作肯定会先完成；
3. 单个操作是原子性的。前面提到，元素进出通道时会触发复制操作，以接收操作为例，操作包含了赋值给新变量、删除通道对应的元素，这两步形成的操作是原子性的。

通道的特性保证了它的简单性，使用者可以省去许多开发上的精力。

## 非缓冲通道

当我们使用make创建一个通道时，不指定容量，或者容量为0，那么该通道是不带缓冲的。

对于非缓冲通道的使用，它的接收操作和发送操作，执行时便会阻塞，只有两者同时存在时，操作才会进行。也就是说，收和发必须同时存在，否则便会阻塞。

## 单向通道

通道可以是单向的，在声明或初始化通道时，我们可以指定通道是`send-only`还是`receievd-only`，只需要在关键字`chan`的左边或右边加上`<-`即可。

```Go
// chan1 是一个send-only通道，只进不出
chan1 := make(chan<- int, 5)

// chan2 是一个received-only通道，只出不进
chan2 := make(<-chan int, 5)
```

> 单向通道可以起到约束作用，比如作为方法的参数，它可以限制方法对通道的使用。

比如，下面的方法，它限制了变量 ch 只能接收，不能发送
```Go
func receivedOnlyChannel(ch <-chan int) {
	fmt.Println(<-ch)
}
```

然后我们可以向 receivedOnlyChannel 传入通道变量。

```Go
chan3 := make(chan int, 5)
chan3 <- 1

receivedOnlyChannel(chan3)
```

## 注意Panic

如果对通道使用不当，会造成panic发生。

- 当通道关闭后，再次对通道进行关闭，会引发panic；
- 当通道关闭后，对其进行发送操作，会引发panic；
- 当我们只有一个goroutine，而通道发生了阻塞，会引发panic：`all goroutines are asleep`，程序死锁。

## select语句

TODO
