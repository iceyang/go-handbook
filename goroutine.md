# 协程 goroutine

我们前面介绍过`channel`数据类型，它是传递消息的载体，是并发安全的。Go 语言采用了 CSP 的并发模型，除了`channel`外，`goroutine`也是它的基础。

`goroutine`也叫`Go协程`，协程可以看做是轻量级线程。`Go`拥有强大的系统级线程调度器，来统一调度`goroutine`，调度开销远小于系统级线程调度，使得我们可以非常简单的写出高并发程序。

## 如何使用 goroutine

我们先通过一个简单的例子看`Go`中的协程是怎么用的。

```Go
package main

import (
	"fmt"
	"time"
)

func main() {
	go func() {
		for i := 1; i <= 10; i++ {
			fmt.Print(i, " ")
		}
	}()
	time.Sleep(time.Second)
}
```

通过执行上面的代码，我们可以得到输出：

```
1 2 3 4 5 6 7 8 9 10
```

在`Go`语言使用协程很简单，只需要在函数方法前使用关键字`go`，那么这个函数调用就会变成一个协程。

上面的代码中我们使用了一个匿名函数，函数内容是打印1到10的内容。

> 眼尖的你可能会发现，`go`语句后面跟随了执行了一条睡眠1秒的语句，你可以尝试把它去掉，看看执行效果会是如何。在文章的后面部分，我们会讲到`Go`协程的调度原理和调度过程，明白了之后就会理解为何是这个输出结果。

下面我们来看另外一个例子：

```Go
package main

import (
	"fmt"
	"time"
)

func main() {
	for i := 1; i <= 10; i++ {
		go fmt.Print(i, " ")
	}
	time.Sleep(time.Second)
}
```

`例子2`跟`例子1`不同的是，我们将协程的使用放到`fmt.Print`函数上，从代码可以明显看出，程序的执行将会开启10个协程，分别打印`i`的内容，下面是我调用的一次执行结果：

```
1 3 6 7 5 9 4 10 2 8
```

不知道结果有没有在你的预料之中，这次的输出并不是顺序的1到10，而是乱序的输出，而且每次执行都可能不一样。原因在于协程是并发的执行，在`for`循环中，我们开启了协程，但却无法决定他们的执行顺序，这个是由`Go`运行时调度决定的。

最后是`例子3`：

```Go
package main

import (
	"fmt"
	"time"
)

func main() {
	for i := 1; i <= 10; i++ {
		go func() {
			fmt.Print(i, " ")
		}()
	}
	time.Sleep(time.Second)
}
```

我们把匿名函数放到`for`循环内，传入`i`进行打印。这次，你猜猜结果会是什么，然后动手实验一下。

为了知道和理解上面3个例子的最终行为，我们需要对`Go`语言调度`goroutine`的原理进行了解。

## Go 如何调度 goroutine

TODO

## 协程 VS 线程

## 总结
